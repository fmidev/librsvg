diff --new-file --recursive --unified librsvg-2.40.6-orig/configure.in librsvg-2.40.6/configure.in
--- librsvg-2.40.6-orig/configure.in	2014-12-03 10:23:51.000000000 +0000
+++ librsvg-2.40.6/configure.in	2014-10-21 08:33:18.000000000 +0000
@@ -111,14 +111,7 @@
 
 PKG_CHECK_MODULES([GMODULE],[gmodule-2.0])
 
-case "$host" in
-  *-*-mingw*)
-    PKG_CHECK_MODULES([RSVG_CONVERT],[gio-2.0 gio-windows-2.0 gdk-pixbuf-2.0 cairo pangocairo])
-    ;;
-  *)
-    PKG_CHECK_MODULES([RSVG_CONVERT],[gio-2.0 gio-unix-2.0 gdk-pixbuf-2.0 cairo pangocairo])
-    ;;
-esac
+PKG_CHECK_MODULES([RSVG_CONVERT],[gio-2.0 gio-unix-2.0 gdk-pixbuf-2.0 cairo pangocairo])
 
 dnl ===========================================================================
 
diff --new-file --recursive --unified librsvg-2.40.6-orig/gtk-doc.make librsvg-2.40.6/gtk-doc.make
--- librsvg-2.40.6-orig/gtk-doc.make	1970-01-01 00:00:00.000000000 +0000
+++ librsvg-2.40.6/gtk-doc.make	2014-03-03 08:11:48.000000000 +0000
@@ -0,0 +1,276 @@
+# -*- mode: makefile -*-
+
+####################################
+# Everything below here is generic #
+####################################
+
+if GTK_DOC_USE_LIBTOOL
+GTKDOC_CC = $(LIBTOOL) --tag=CC --mode=compile $(CC) $(INCLUDES) $(GTKDOC_DEPS_CFLAGS) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+GTKDOC_LD = $(LIBTOOL) --tag=CC --mode=link $(CC) $(GTKDOC_DEPS_LIBS) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS)
+GTKDOC_RUN = $(LIBTOOL) --mode=execute
+else
+GTKDOC_CC = $(CC) $(INCLUDES) $(GTKDOC_DEPS_CFLAGS) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+GTKDOC_LD = $(CC) $(GTKDOC_DEPS_LIBS) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS)
+GTKDOC_RUN =
+endif
+
+# We set GPATH here; this gives us semantics for GNU make
+# which are more like other make's VPATH, when it comes to
+# whether a source that is a target of one rule is then
+# searched for in VPATH/GPATH.
+#
+GPATH = $(srcdir)
+
+TARGET_DIR=$(HTML_DIR)/$(DOC_MODULE)
+
+SETUP_FILES = \
+	$(content_files)		\
+	$(DOC_MAIN_SGML_FILE)		\
+	$(DOC_MODULE)-sections.txt	\
+	$(DOC_MODULE)-overrides.txt
+
+EXTRA_DIST = 				\
+	$(HTML_IMAGES)			\
+	$(SETUP_FILES)
+
+DOC_STAMPS=setup-build.stamp scan-build.stamp sgml-build.stamp \
+	html-build.stamp pdf-build.stamp \
+	sgml.stamp html.stamp pdf.stamp
+
+SCANOBJ_FILES = 		 \
+	$(DOC_MODULE).args 	 \
+	$(DOC_MODULE).hierarchy  \
+	$(DOC_MODULE).interfaces \
+	$(DOC_MODULE).prerequisites \
+	$(DOC_MODULE).signals
+
+REPORT_FILES = \
+	$(DOC_MODULE)-undocumented.txt \
+	$(DOC_MODULE)-undeclared.txt \
+	$(DOC_MODULE)-unused.txt
+
+CLEANFILES = $(SCANOBJ_FILES) $(REPORT_FILES) $(DOC_STAMPS)
+
+if ENABLE_GTK_DOC
+if GTK_DOC_BUILD_HTML
+HTML_BUILD_STAMP=html-build.stamp
+else
+HTML_BUILD_STAMP=
+endif
+if GTK_DOC_BUILD_PDF
+PDF_BUILD_STAMP=pdf-build.stamp
+else
+PDF_BUILD_STAMP=
+endif
+
+all-local: $(HTML_BUILD_STAMP) $(PDF_BUILD_STAMP)
+else
+all-local:
+endif
+
+docs: $(HTML_BUILD_STAMP) $(PDF_BUILD_STAMP)
+
+$(REPORT_FILES): sgml-build.stamp
+
+#### setup ####
+
+GTK_DOC_V_SETUP=$(GTK_DOC_V_SETUP_$(V))
+GTK_DOC_V_SETUP_=$(GTK_DOC_V_SETUP_$(AM_DEFAULT_VERBOSITY))
+GTK_DOC_V_SETUP_0=@echo "  DOC   Preparing build";
+
+setup-build.stamp:
+	-$(GTK_DOC_V_SETUP)if test "$(abs_srcdir)" != "$(abs_builddir)" ; then \
+	    files=`echo $(SETUP_FILES) $(expand_content_files) $(DOC_MODULE).types`; \
+	    if test "x$$files" != "x" ; then \
+	        for file in $$files ; do \
+	            test -f $(abs_srcdir)/$$file && \
+	                cp -pu $(abs_srcdir)/$$file $(abs_builddir)/$$file || true; \
+	        done; \
+	    fi; \
+	fi
+	$(AM_V_at)touch setup-build.stamp
+
+
+#### scan ####
+
+GTK_DOC_V_SCAN=$(GTK_DOC_V_SCAN_$(V))
+GTK_DOC_V_SCAN_=$(GTK_DOC_V_SCAN_$(AM_DEFAULT_VERBOSITY))
+GTK_DOC_V_SCAN_0=@echo "  DOC   Scanning header files";
+
+GTK_DOC_V_INTROSPECT=$(GTK_DOC_V_INTROSPECT_$(V))
+GTK_DOC_V_INTROSPECT_=$(GTK_DOC_V_INTROSPECT_$(AM_DEFAULT_VERBOSITY))
+GTK_DOC_V_INTROSPECT_0=@echo "  DOC   Introspecting gobjects";
+
+scan-build.stamp: $(HFILE_GLOB) $(CFILE_GLOB)
+	$(GTK_DOC_V_SCAN)_source_dir='' ; \
+	for i in $(DOC_SOURCE_DIR) ; do \
+	    _source_dir="$${_source_dir} --source-dir=$$i" ; \
+	done ; \
+	gtkdoc-scan --module=$(DOC_MODULE) --ignore-headers="$(IGNORE_HFILES)" $${_source_dir} $(SCAN_OPTIONS) $(EXTRA_HFILES)
+	$(GTK_DOC_V_INTROSPECT)if grep -l '^..*$$' $(DOC_MODULE).types > /dev/null 2>&1 ; then \
+	    scanobj_options=""; \
+	    gtkdoc-scangobj 2>&1 --help | grep  >/dev/null "\-\-verbose"; \
+	    if test "$(?)" = "0"; then \
+	        if test "x$(V)" = "x1"; then \
+	            scanobj_options="--verbose"; \
+	        fi; \
+	    fi; \
+	    CC="$(GTKDOC_CC)" LD="$(GTKDOC_LD)" RUN="$(GTKDOC_RUN)" CFLAGS="$(GTKDOC_CFLAGS) $(CFLAGS)" LDFLAGS="$(GTKDOC_LIBS) $(LDFLAGS)" \
+	    gtkdoc-scangobj $(SCANGOBJ_OPTIONS) $$scanobj_options --module=$(DOC_MODULE); \
+	else \
+	    for i in $(SCANOBJ_FILES) ; do \
+	        test -f $$i || touch $$i ; \
+	    done \
+	fi
+	$(AM_V_at)touch scan-build.stamp
+
+$(DOC_MODULE)-decl.txt $(SCANOBJ_FILES) $(DOC_MODULE)-sections.txt $(DOC_MODULE)-overrides.txt: scan-build.stamp
+	@true
+
+#### xml ####
+
+GTK_DOC_V_XML=$(GTK_DOC_V_XML_$(V))
+GTK_DOC_V_XML_=$(GTK_DOC_V_XML_$(AM_DEFAULT_VERBOSITY))
+GTK_DOC_V_XML_0=@echo "  DOC   Building XML";
+
+sgml-build.stamp: setup-build.stamp $(DOC_MODULE)-decl.txt $(SCANOBJ_FILES) $(DOC_MODULE)-sections.txt $(DOC_MODULE)-overrides.txt $(expand_content_files)
+	$(GTK_DOC_V_XML)_source_dir='' ; \
+	for i in $(DOC_SOURCE_DIR) ; do \
+	    _source_dir="$${_source_dir} --source-dir=$$i" ; \
+	done ; \
+	gtkdoc-mkdb --module=$(DOC_MODULE) --output-format=xml --expand-content-files="$(expand_content_files)" --main-sgml-file=$(DOC_MAIN_SGML_FILE) $${_source_dir} $(MKDB_OPTIONS)
+	$(AM_V_at)touch sgml-build.stamp
+
+sgml.stamp: sgml-build.stamp
+	@true
+
+#### html ####
+
+GTK_DOC_V_HTML=$(GTK_DOC_V_HTML_$(V))
+GTK_DOC_V_HTML_=$(GTK_DOC_V_HTML_$(AM_DEFAULT_VERBOSITY))
+GTK_DOC_V_HTML_0=@echo "  DOC   Building HTML";
+
+GTK_DOC_V_XREF=$(GTK_DOC_V_XREF_$(V))
+GTK_DOC_V_XREF_=$(GTK_DOC_V_XREF_$(AM_DEFAULT_VERBOSITY))
+GTK_DOC_V_XREF_0=@echo "  DOC   Fixing cross-references";
+
+html-build.stamp: sgml.stamp $(DOC_MAIN_SGML_FILE) $(content_files)
+	$(GTK_DOC_V_HTML)rm -rf html && mkdir html && \
+	mkhtml_options=""; \
+	gtkdoc-mkhtml 2>&1 --help | grep  >/dev/null "\-\-verbose"; \
+	if test "$(?)" = "0"; then \
+	  if test "x$(V)" = "x1"; then \
+	    mkhtml_options="$$mkhtml_options --verbose"; \
+	  fi; \
+	fi; \
+	gtkdoc-mkhtml 2>&1 --help | grep  >/dev/null "\-\-path"; \
+	if test "$(?)" = "0"; then \
+	  mkhtml_options="$$mkhtml_options --path=\"$(abs_srcdir)\""; \
+	fi; \
+	cd html && gtkdoc-mkhtml $$mkhtml_options $(MKHTML_OPTIONS) $(DOC_MODULE) ../$(DOC_MAIN_SGML_FILE)
+	-@test "x$(HTML_IMAGES)" = "x" || \
+	for file in $(HTML_IMAGES) ; do \
+	  if test -f $(abs_srcdir)/$$file ; then \
+	    cp $(abs_srcdir)/$$file $(abs_builddir)/html; \
+	  fi; \
+	  if test -f $(abs_builddir)/$$file ; then \
+	    cp $(abs_builddir)/$$file $(abs_builddir)/html; \
+	  fi; \
+	done;
+	$(GTK_DOC_V_XREF)gtkdoc-fixxref --module=$(DOC_MODULE) --module-dir=html --html-dir=$(HTML_DIR) $(FIXXREF_OPTIONS)
+	$(AM_V_at)touch html-build.stamp
+
+#### pdf ####
+
+GTK_DOC_V_PDF=$(GTK_DOC_V_PDF_$(V))
+GTK_DOC_V_PDF_=$(GTK_DOC_V_PDF_$(AM_DEFAULT_VERBOSITY))
+GTK_DOC_V_PDF_0=@echo "  DOC   Building PDF";
+
+pdf-build.stamp: sgml.stamp $(DOC_MAIN_SGML_FILE) $(content_files)
+	$(GTK_DOC_V_PDF)rm -f $(DOC_MODULE).pdf && \
+	mkpdf_options=""; \
+	gtkdoc-mkpdf 2>&1 --help | grep  >/dev/null "\-\-verbose"; \
+	if test "$(?)" = "0"; then \
+	  if test "x$(V)" = "x1"; then \
+	    mkpdf_options="$$mkpdf_options --verbose"; \
+	  fi; \
+	fi; \
+	if test "x$(HTML_IMAGES)" != "x"; then \
+	  for img in $(HTML_IMAGES); do \
+	    part=`dirname $$img`; \
+	    echo $$mkpdf_options | grep >/dev/null "\-\-imgdir=$$part "; \
+	    if test $$? != 0; then \
+	      mkpdf_options="$$mkpdf_options --imgdir=$$part"; \
+	    fi; \
+	  done; \
+	fi; \
+	gtkdoc-mkpdf --path="$(abs_srcdir)" $$mkpdf_options $(DOC_MODULE) $(DOC_MAIN_SGML_FILE) $(MKPDF_OPTIONS)
+	$(AM_V_at)touch pdf-build.stamp
+
+##############
+
+clean-local:
+	@rm -f *~ *.bak
+	@rm -rf .libs
+
+distclean-local:
+	@rm -rf xml html $(REPORT_FILES) $(DOC_MODULE).pdf \
+	    $(DOC_MODULE)-decl-list.txt $(DOC_MODULE)-decl.txt
+	@if test "$(abs_srcdir)" != "$(abs_builddir)" ; then \
+	    rm -f $(SETUP_FILES) $(expand_content_files) $(DOC_MODULE).types; \
+	fi
+
+maintainer-clean-local:
+	@rm -rf xml html
+
+install-data-local:
+	@installfiles=`echo $(builddir)/html/*`; \
+	if test "$$installfiles" = '$(builddir)/html/*'; \
+	then echo 1>&2 'Nothing to install' ; \
+	else \
+	  if test -n "$(DOC_MODULE_VERSION)"; then \
+	    installdir="$(DESTDIR)$(TARGET_DIR)-$(DOC_MODULE_VERSION)"; \
+	  else \
+	    installdir="$(DESTDIR)$(TARGET_DIR)"; \
+	  fi; \
+	  $(mkinstalldirs) $${installdir} ; \
+	  for i in $$installfiles; do \
+	    echo ' $(INSTALL_DATA) '$$i ; \
+	    $(INSTALL_DATA) $$i $${installdir}; \
+	  done; \
+	  if test -n "$(DOC_MODULE_VERSION)"; then \
+	    mv -f $${installdir}/$(DOC_MODULE).devhelp2 \
+	      $${installdir}/$(DOC_MODULE)-$(DOC_MODULE_VERSION).devhelp2; \
+	  fi; \
+	  $(GTKDOC_REBASE) --relative --dest-dir=$(DESTDIR) --html-dir=$${installdir}; \
+	fi
+
+uninstall-local:
+	@if test -n "$(DOC_MODULE_VERSION)"; then \
+	  installdir="$(DESTDIR)$(TARGET_DIR)-$(DOC_MODULE_VERSION)"; \
+	else \
+	  installdir="$(DESTDIR)$(TARGET_DIR)"; \
+	fi; \
+	rm -rf $${installdir}
+
+#
+# Require gtk-doc when making dist
+#
+if ENABLE_GTK_DOC
+dist-check-gtkdoc: docs
+else
+dist-check-gtkdoc:
+	@echo "*** gtk-doc must be installed and enabled in order to make dist"
+	@false
+endif
+
+dist-hook: dist-check-gtkdoc dist-hook-local
+	@mkdir $(distdir)/html
+	@cp ./html/* $(distdir)/html
+	@-cp ./$(DOC_MODULE).pdf $(distdir)/
+	@-cp ./$(DOC_MODULE).types $(distdir)/
+	@-cp ./$(DOC_MODULE)-sections.txt $(distdir)/
+	@cd $(distdir) && rm -f $(DISTCLEANFILES)
+	@$(GTKDOC_REBASE) --online --relative --html-dir=$(distdir)/html
+
+.PHONY : dist-hook-local docs
diff --new-file --recursive --unified librsvg-2.40.6-orig/Makefile.am librsvg-2.40.6/Makefile.am
--- librsvg-2.40.6-orig/Makefile.am	2014-12-03 10:23:51.000000000 +0000
+++ librsvg-2.40.6/Makefile.am	2014-10-21 08:33:18.000000000 +0000
@@ -3,6 +3,8 @@
 NULL =
 BUILT_SOURCES =
 
+ACLOCAL_AMFLAGS = ${ACLOCAL_FLAGS} -I m4
+
 lib_LTLIBRARIES = librsvg-@RSVG_API_MAJOR_VERSION@.la
 
 bin_PROGRAMS = rsvg-convert
@@ -69,6 +71,8 @@
 	rsvg-cairo.h		\
 	librsvg-features.h 	\
 	librsvg-enum-types.h	\
+	rsvg-twisted.c		\
+	rsvg-twisted.h		\
 	$(NULL)
 
 librsvg_@RSVG_API_MAJOR_VERSION@_la_CPPFLAGS = \
diff --new-file --recursive --unified librsvg-2.40.6-orig/NEWS librsvg-2.40.6/NEWS
--- librsvg-2.40.6-orig/NEWS	2014-12-03 10:23:51.000000000 +0000
+++ librsvg-2.40.6/NEWS	2014-03-03 08:00:12.000000000 +0000
@@ -1,8 +1,3 @@
-Version 2.40.6
-- MinGW build fixes
-- Fix path data number parsing
-- Fix build with newer libtool
-
 Version 2.40.1
 - Build fixes
 - Crash fixes
diff --new-file --recursive --unified librsvg-2.40.6-orig/rsvg-base.c librsvg-2.40.6/rsvg-base.c
--- librsvg-2.40.6-orig/rsvg-base.c	2014-12-03 10:23:51.000000000 +0000
+++ librsvg-2.40.6/rsvg-base.c	2014-10-21 08:33:18.000000000 +0000
@@ -58,15 +58,6 @@
 #include "rsvg-xml.h"
 
 /*
- * XXX: Perhaps do a GIO-based implementation for
- * realpath() or use gnulib implementation for this
- * https://bugzilla.gnome.org/show_bug.cgi?id=710163
- */
-#ifdef G_OS_WIN32
-#define realpath(a,b) _fullpath(b,a,_MAX_PATH)
-#endif
-
-/*
  * This is configurable at runtime
  */
 #define RSVG_DEFAULT_DPI_X 90.0
@@ -282,6 +273,8 @@
         newnode = rsvg_new_tspan ();
     else if (!strcmp (name, "tref"))
         newnode = rsvg_new_tref ();
+    else if (!strcmp (name, "textPath"))
+        newnode = rsvg_new_textpath ();
     else {
 		/* hack for bug 401115. whenever we encounter a node we don't understand, push it into a group. 
 		   this will allow us to handle things like conditionals properly. */
@@ -753,6 +746,7 @@
     if (ctx->priv->currentnode) {
         RsvgNodeType type = RSVG_NODE_TYPE (ctx->priv->currentnode);
         if (type == RSVG_NODE_TYPE_TSPAN ||
+            type == RSVG_NODE_TYPE_TEXTPATH ||
             type == RSVG_NODE_TYPE_TEXT) {
             guint i;
 
@@ -767,6 +761,9 @@
                 else if (RSVG_NODE_TYPE (node) == RSVG_NODE_TYPE_TSPAN) {
                     self = NULL;
                 }
+                else if (RSVG_NODE_TYPE (node) == RSVG_NODE_TYPE_TEXTPATH) {
+                    self = NULL;
+                }
             }
 
             if (self != NULL) {
diff --new-file --recursive --unified librsvg-2.40.6-orig/rsvg-cairo-draw.c librsvg-2.40.6/rsvg-cairo-draw.c
--- librsvg-2.40.6-orig/rsvg-cairo-draw.c	2014-12-03 10:23:51.000000000 +0000
+++ librsvg-2.40.6/rsvg-cairo-draw.c	2014-03-03 09:11:52.000000000 +0000
@@ -35,12 +35,13 @@
 #include "rsvg-filter.h"
 #include "rsvg-structure.h"
 #include "rsvg-image.h"
-
+#include "rsvg-twisted.h"
 #include <math.h>
 #include <string.h>
 
 #include <pango/pangocairo.h>
 
+
 static const cairo_user_data_key_t surface_pixel_data_key;
 
 static void
@@ -375,8 +376,14 @@
     return context;
 }
 
+/*
+ * TODO: Text should not be displayed before/after the path.
+ *       x may be negative if startOffset is negative.
+ */
+
 void
-rsvg_cairo_render_pango_layout (RsvgDrawingCtx * ctx, PangoLayout * layout, double x, double y)
+rsvg_cairo_render_pango_layout (RsvgDrawingCtx * ctx, PangoLayout * layout,
+                                double x, double y, const cairo_path_t * path)
 {
     RsvgCairoRender *render = RSVG_CAIRO_RENDER (ctx->render);
     RsvgState *state = rsvg_current_state (ctx);
@@ -384,6 +391,7 @@
     RsvgBbox bbox;
     PangoGravity gravity = pango_context_get_gravity (pango_layout_get_context (layout));
     double rotation;
+    cairo_path_t * textpath = NULL, * flatpath = NULL;
 
     cairo_set_antialias (render->cr, state->text_rendering_type);
 
@@ -406,7 +414,25 @@
     bbox.virgin = 0;
 
     rotation = pango_gravity_to_rotation (gravity);
-    if (state->fill) {
+
+    /* Calculate the twisted paths only once for stroke & fill */
+    if(path != NULL) {
+        cairo_save(render->cr);
+        cairo_set_tolerance(render->cr, 0.01);
+        cairo_append_path(render->cr, path);
+        flatpath = cairo_copy_path_flat(render->cr);
+
+        cairo_new_path(render->cr);
+        cairo_move_to(render->cr, x, y);
+        pango_cairo_layout_path(render->cr, layout);
+        map_path_onto(render->cr,flatpath);
+        textpath = cairo_copy_path(render->cr);
+
+        cairo_path_destroy(flatpath);
+        cairo_restore(render->cr);
+    }
+            
+    if(state->fill) {
         cairo_save (render->cr);
         cairo_move_to (render->cr, x, y);
         rsvg_bbox_insert (&render->bbox, &bbox);
@@ -417,7 +443,13 @@
                                        bbox, rsvg_current_state (ctx)->current_color);
         if (rotation != 0.)
             cairo_rotate (render->cr, -rotation);
-        pango_cairo_show_layout (render->cr, layout);
+        if(path == NULL || path->num_data==0 ) {
+            pango_cairo_show_layout (render->cr, layout);
+        } else {
+            cairo_new_path(render->cr);
+            cairo_append_path(render->cr, textpath);
+            cairo_fill(render->cr);
+        }
         cairo_restore (render->cr);
     }
 
@@ -425,16 +457,15 @@
         cairo_save (render->cr);
         cairo_move_to (render->cr, x, y);
         rsvg_bbox_insert (&render->bbox, &bbox);
-
+        
         _set_source_rsvg_paint_server (ctx,
                                        state->current_color,
                                        state->stroke,
                                        state->stroke_opacity,
                                        bbox, rsvg_current_state (ctx)->current_color);
-
+        
         if (rotation != 0.)
             cairo_rotate (render->cr, -rotation);
-        pango_cairo_layout_path (render->cr, layout);
 
         cairo_set_line_width (render->cr, _rsvg_css_normalize_length (&state->stroke_width, ctx, 'h'));
         cairo_set_miter_limit (render->cr, state->miter_limit);
@@ -442,9 +473,22 @@
         cairo_set_line_join (render->cr, (cairo_line_join_t) state->join);
         cairo_set_dash (render->cr, state->dash.dash, state->dash.n_dash,
                         _rsvg_css_normalize_length (&state->dash.offset, ctx, 'o'));
-        cairo_stroke (render->cr);
+
+        if(path == NULL) {
+            pango_cairo_layout_path (render->cr, layout);
+            cairo_stroke (render->cr);
+        } else {
+            cairo_new_path(render->cr);
+            cairo_append_path(render->cr, textpath);
+            cairo_stroke(render->cr);
+
+        }
         cairo_restore (render->cr);
     }
+
+    if(textpath != NULL)
+        cairo_path_destroy(textpath);
+
 }
 
 void
diff --new-file --recursive --unified librsvg-2.40.6-orig/rsvg-cairo-draw.h librsvg-2.40.6/rsvg-cairo-draw.h
--- librsvg-2.40.6-orig/rsvg-cairo-draw.h	2014-12-03 10:23:51.000000000 +0000
+++ librsvg-2.40.6/rsvg-cairo-draw.h	2014-03-03 08:31:55.000000000 +0000
@@ -36,7 +36,7 @@
 PangoContext    *rsvg_cairo_create_pango_context    (RsvgDrawingCtx *ctx);
 G_GNUC_INTERNAL
 void         rsvg_cairo_render_pango_layout	    (RsvgDrawingCtx *ctx, PangoLayout *layout, 
-                                                 double x, double y);
+                                                 double x, double y, const cairo_path_t * path);
 G_GNUC_INTERNAL
 void         rsvg_cairo_render_path             (RsvgDrawingCtx *ctx, 
                                                  const cairo_path_t *path);
diff --new-file --recursive --unified librsvg-2.40.6-orig/rsvg-convert.c librsvg-2.40.6/rsvg-convert.c
--- librsvg-2.40.6-orig/rsvg-convert.c	2014-12-03 10:23:51.000000000 +0000
+++ librsvg-2.40.6/rsvg-convert.c	2014-10-21 08:33:18.000000000 +0000
@@ -36,11 +36,7 @@
 #include <locale.h>
 #include <glib/gi18n.h>
 #include <gio/gio.h>
-#ifdef _WIN32
-#include <gio/gwin32inputstream.h>
-#else
 #include <gio/gunixinputstream.h>
-#endif
 
 #include "rsvg-css.h"
 #include "rsvg.h"
@@ -217,11 +213,7 @@
 
         if (using_stdin) {
             file = NULL;
-#ifdef _WIN32
-            stream = g_win32_input_stream_new (STDIN_FILENO, FALSE);
-#else
             stream = g_unix_input_stream_new (STDIN_FILENO, FALSE);
-#endif
         } else {
             GFileInfo *file_info;
             gboolean compressed = FALSE;
diff --new-file --recursive --unified librsvg-2.40.6-orig/rsvg-path.c librsvg-2.40.6/rsvg-path.c
--- librsvg-2.40.6-orig/rsvg-path.c	2014-12-03 10:23:51.000000000 +0000
+++ librsvg-2.40.6/rsvg-path.c	2014-03-03 08:00:12.000000000 +0000
@@ -568,135 +568,100 @@
     rsvg_parse_path_do_cmd (ctx, FALSE);    
 }
 
-#define RSVGN_IN_PREINTEGER  0
-#define RSVGN_IN_INTEGER     1
-#define RSVGN_IN_FRACTION    2
-#define RSVGN_IN_PREEXPONENT 3
-#define RSVGN_IN_EXPONENT    4
-
-#define RSVGN_GOT_SIGN          0x1
-#define RSVGN_GOT_EXPONENT_SIGN 0x2
-
-/* Returns the length of the number parsed, so it can be skipped
- * in rsvg_parse_path_data. Calls rsvg_path_end_number to have the number
- * processed in its command.
- */
-static int
-rsvg_parse_number (RSVGParsePathCtx * ctx, const char *data)
-{
-    int length = 0;
-    int in = RSVGN_IN_PREINTEGER; /* Current location within the number */
-    int got = 0x0; /* [bitfield] Having 2 of each of these is an error */
-    gboolean end = FALSE; /* Set to true if the number should end after a char */
-    gboolean error = FALSE; /* Set to true if the number ended due to an error */
-
-    double value = 0.0;
-    double fraction = 1.0;
-    int sign = +1; /* Presume the INTEGER is positive if it has no sign */
-    int exponent = 0;
-    int exponent_sign = +1; /* Presume the EXPONENT is positive if it has no sign */
-
-    while (data[length] != '\0' && !end && !error) {
-        char c = data[length];
-        switch (in) {
-            case RSVGN_IN_PREINTEGER: /* No numbers yet, we're just starting out */
-                /* LEGAL: + - .->FRACTION DIGIT->INTEGER */
-                if (c == '+' || c == '-') {
-                    if (got & RSVGN_GOT_SIGN) {
-                        error = TRUE; /* Two signs: not allowed */
-                    } else {
-                        sign = c == '+' ? +1 : -1;
-                        got |= RSVGN_GOT_SIGN;
-                    }
-                } else if (c == '.') {
-                    in = RSVGN_IN_FRACTION;
-                } else if (c >= '0' && c <= '9') {
-                    value = c - '0';
-                    in = RSVGN_IN_INTEGER;
-                }
-                break;
-            case RSVGN_IN_INTEGER: /* Previous character(s) was/were digit(s) */
-                /* LEGAL: DIGIT .->FRACTION E->PREEXPONENT */
-                if (c >= '0' && c <= '9') {
-                    value = value * 10 + (c - '0');
-                }
-                else if (c == '.') {
-                    in = RSVGN_IN_FRACTION;
-                }
-                else if (c == 'e' || c == 'E') {
-                    in = RSVGN_IN_PREEXPONENT;
-                }
-                else {
-                    end = TRUE;
-                }
-                break;
-            case RSVGN_IN_FRACTION: /* Previously, digit(s) in the fractional part */
-                /* LEGAL: DIGIT E->PREEXPONENT */
-                if (c >= '0' && c <= '9') {
-                    fraction *= 0.1;
-                    value += fraction * (c - '0');
-                }
-                else if (c == 'e' || c == 'E') {
-                    in = RSVGN_IN_PREEXPONENT;
-                }
-                else {
-                    end = TRUE;
-                }
-                break;
-            case RSVGN_IN_PREEXPONENT: /* Right after E */
-                /* LEGAL: + - DIGIT->EXPONENT */
-                if (c == '+' || c == '-') {
-                    if (got & RSVGN_GOT_EXPONENT_SIGN) {
-                        error = TRUE; /* Two signs: not allowed */
-                    } else {
-                        exponent_sign = c == '+' ? +1 : -1;
-                        got |= RSVGN_GOT_EXPONENT_SIGN;
-                    }
-                } else if (c >= '0' && c <= '9') {
-                    exponent = c - '0';
-                    in = RSVGN_IN_EXPONENT;
-                }
-                break;
-            case RSVGN_IN_EXPONENT: /* After E and the sign, if applicable */
-                /* LEGAL: DIGIT */
-                if (c >= '0' && c <= '9') {
-                    exponent = exponent * 10 + (c - '0');
-                } else {
-                    end = TRUE;
-                }
-                break;
-        }
-        length++;
-    }
-
-    /* TODO? if (error) report_the_error_somehow(); */
-    rsvg_path_end_of_number(ctx, value, sign, exponent_sign, exponent);
-    return end /* && !error */ ? length - 1 : length;
-}
-
 static void
 rsvg_parse_path_data (RSVGParsePathCtx * ctx, const char *data)
 {
     int i = 0;
+    double val = 0;
     char c = 0;
+    gboolean in_num = FALSE;
+    gboolean in_frac = FALSE;
+    gboolean in_exp = FALSE;
+    gboolean exp_wait_sign = FALSE;
+    int sign = 0;
+    int exp = 0;
+    int exp_sign = 0;
+    double frac = 0.0;
 
-    for (i = 0; data[i] != '\0'; i++) {
+    in_num = FALSE;
+    for (i = 0;; i++) {
         c = data[i];
-        if (c >= '0' && c <= '9' || c == '+' || c == '-' || c == '.') {
+        if (c >= '0' && c <= '9') {
             /* digit */
-            i += rsvg_parse_number(ctx, data + i) - 1;
+            if (in_num) {
+                if (in_exp) {
+                    exp = (exp * 10) + c - '0';
+                    exp_wait_sign = FALSE;
+                } else if (in_frac)
+                    val += (frac *= 0.1) * (c - '0');
+                else
+                    val = (val * 10) + c - '0';
+            } else {
+                in_num = TRUE;
+                in_frac = FALSE;
+                in_exp = FALSE;
+                exp = 0;
+                exp_sign = 1;
+                exp_wait_sign = FALSE;
+                val = c - '0';
+                sign = 1;
+            }
+        } else if (c == '.') {
+            if (!in_num) {
+                in_frac = TRUE;
+                val = 0;
+            }
+            else if (in_frac) {
+                rsvg_path_end_of_number(ctx, val, sign, exp_sign, exp);
+                in_frac = FALSE;
+                in_exp = FALSE;
+                exp = 0;
+                exp_sign = 1;
+                exp_wait_sign = FALSE;
+                val = 0;
+                sign = 1;
+            }
+            else {
+                in_frac = TRUE;
+            }
+            in_num = TRUE;
+            frac = 1;
+        } else if ((c == 'E' || c == 'e') && in_num) {
+            in_exp = TRUE;
+            exp_wait_sign = TRUE;
+            exp = 0;
+            exp_sign = 1;
+        } else if ((c == '+' || c == '-') && in_exp) {
+            exp_sign = c == '+' ? 1 : -1;
+        } else if (in_num) {
+            /* end of number */
+            rsvg_path_end_of_number(ctx, val, sign, exp_sign, exp);
+            in_num = FALSE;
+        }
+
+        if (c == '\0')
+            break;
+        else if ((c == '+' || c == '-') && !exp_wait_sign) {
+            sign = c == '+' ? 1 : -1;
+            val = 0;
+            in_num = TRUE;
+            in_frac = FALSE;
+            in_exp = FALSE;
+            exp = 0;
+            exp_sign = 1;
+            exp_wait_sign = FALSE;
         } else if (c == 'z' || c == 'Z') {
             if (ctx->param)
                 rsvg_parse_path_do_cmd (ctx, TRUE);
             rsvg_path_builder_close_path (&ctx->builder);
 
             ctx->cp = ctx->rp = g_array_index (ctx->builder.path_data, cairo_path_data_t, ctx->builder.path_data->len - 1);
-        } else if (c >= 'A' && c < 'Z' && c != 'E') {
+        } else if (c >= 'A' && c <= 'Z' && c != 'E') {
             if (ctx->param)
                 rsvg_parse_path_do_cmd (ctx, TRUE);
             ctx->cmd = c + 'a' - 'A';
             ctx->rel = FALSE;
-        } else if (c >= 'a' && c < 'z' && c != 'e') {
+        } else if (c >= 'a' && c <= 'z' && c != 'e') {
             if (ctx->param)
                 rsvg_parse_path_do_cmd (ctx, TRUE);
             ctx->cmd = c;
diff --new-file --recursive --unified librsvg-2.40.6-orig/rsvg-private.h librsvg-2.40.6/rsvg-private.h
--- librsvg-2.40.6-orig/rsvg-private.h	2014-12-03 10:23:51.000000000 +0000
+++ librsvg-2.40.6/rsvg-private.h	2014-03-03 08:44:28.000000000 +0000
@@ -220,7 +220,7 @@
 
     PangoContext    *(*create_pango_context)    (RsvgDrawingCtx * ctx);
     void             (*render_pango_layout)	    (RsvgDrawingCtx * ctx, PangoLayout *layout,
-                                                 double x, double y);
+                                                 double x, double y, const cairo_path_t * path);
     void             (*render_path)             (RsvgDrawingCtx * ctx, const cairo_path_t *path);
     void             (*render_surface)          (RsvgDrawingCtx * ctx, cairo_surface_t *surface,
                                                  double x, double y, double w, double h);
@@ -309,6 +309,7 @@
     RSVG_NODE_TYPE_FILTER_PRIMITIVE_SPECULAR_LIGHTING,
     RSVG_NODE_TYPE_FILTER_PRIMITIVE_TILE,
     RSVG_NODE_TYPE_FILTER_PRIMITIVE_TURBULENCE,
+    RSVG_NODE_TYPE_TEXTPATH,
 
 } RsvgNodeType;
 
diff --new-file --recursive --unified librsvg-2.40.6-orig/rsvg-text.c librsvg-2.40.6/rsvg-text.c
--- librsvg-2.40.6-orig/rsvg-text.c	2014-12-03 10:23:51.000000000 +0000
+++ librsvg-2.40.6/rsvg-text.c	2014-03-03 08:48:04.000000000 +0000
@@ -30,6 +30,7 @@
 #include "rsvg-styles.h"
 #include "rsvg-text.h"
 #include "rsvg-css.h"
+#include "rsvg-twisted.h"
 
 #include "rsvg-shapes.h"
 
@@ -49,6 +50,18 @@
     RsvgNode super;
     RsvgNode *link;
 };
+
+typedef struct _RsvgNodeTextPath RsvgNodeTextPath;
+
+struct _RsvgNodeTextPath {
+    RsvgNode super;
+    RsvgLength x, y, dx, dy;
+    RsvgNode *link;			/* the path */
+    RsvgLength startOffset;
+    gboolean stretch;		/* true=stretch, false=align */
+    gboolean autospacing;	/* true=auto, false=exact */
+};
+
 char *
 rsvg_make_valid_utf8 (const char *str, int len)
 {
@@ -150,23 +163,32 @@
 }
 
 static void
- rsvg_text_render_text (RsvgDrawingCtx * ctx, const char *text, gdouble * x, gdouble * y);
+rsvg_text_render_text (RsvgDrawingCtx * ctx, const char *text, gdouble * x, gdouble * y, const cairo_path_t * path);
 
 
 static void
  _rsvg_node_text_type_tspan (RsvgNodeText * self, RsvgDrawingCtx * ctx,
                              gdouble * x, gdouble * y, gboolean * lastwasspace,
-                             gboolean usetextonly);
+                             gboolean usetextonly,
+                             const cairo_path_t * path);
 
 static void
  _rsvg_node_text_type_tref (RsvgNodeTref * self, RsvgDrawingCtx * ctx,
                             gdouble * x, gdouble * y, gboolean * lastwasspace,
-                            gboolean usetextonly);
+                            gboolean usetextonly,
+                            const cairo_path_t * path);
+
+static void
+ _rsvg_node_text_type_textpath (RsvgNodeTextPath * self, RsvgDrawingCtx * ctx,
+                                gdouble * x, gdouble * y, gboolean * lastwasspace,
+                                gboolean usetextonly,
+                                const cairo_path_t * path);
 
 static void
 _rsvg_node_text_type_children (RsvgNode * self, RsvgDrawingCtx * ctx,
                                gdouble * x, gdouble * y, gboolean * lastwasspace,
-                               gboolean usetextonly)
+                               gboolean usetextonly,
+                               const cairo_path_t * path)
 {
     guint i;
 
@@ -178,23 +200,29 @@
         if (type == RSVG_NODE_TYPE_CHARS) {
             RsvgNodeChars *chars = (RsvgNodeChars *) node;
             GString *str = _rsvg_text_chomp (rsvg_current_state (ctx), chars->contents, lastwasspace);
-            rsvg_text_render_text (ctx, str->str, x, y);
+            rsvg_text_render_text (ctx, str->str, x, y, path);
             g_string_free (str, TRUE);
         } else {
             if (usetextonly) {
                 _rsvg_node_text_type_children (node, ctx, x, y, lastwasspace,
-                                               usetextonly);
+                                               usetextonly, path);
             } else {
                 if (type == RSVG_NODE_TYPE_TSPAN) {
                     RsvgNodeText *tspan = (RsvgNodeText *) node;
                     rsvg_state_push (ctx);
                     _rsvg_node_text_type_tspan (tspan, ctx, x, y, lastwasspace,
-                                                usetextonly);
+                                                usetextonly, path);
                     rsvg_state_pop (ctx);
                 } else if (type == RSVG_NODE_TYPE_TREF) {
                     RsvgNodeTref *tref = (RsvgNodeTref *) node;
                     _rsvg_node_text_type_tref (tref, ctx, x, y, lastwasspace,
-                                               usetextonly);
+                                               usetextonly, path);
+                } else if (type == RSVG_NODE_TYPE_TEXTPATH) {
+                    RsvgNodeTextPath *textpath = (RsvgNodeTextPath *) node;
+                    rsvg_state_push (ctx);
+                    _rsvg_node_text_type_textpath (textpath, ctx, x, y, lastwasspace,
+                                                   usetextonly, path);
+                    rsvg_state_pop (ctx);
                 }
             }
         }
@@ -212,6 +240,11 @@
                                gdouble * x, gboolean * lastwasspace,
                                gboolean usetextonly);
 
+static int
+ _rsvg_node_text_length_textpath (RsvgNodeTextPath * self, RsvgDrawingCtx * ctx,
+                                  gdouble * x, gboolean * lastwasspace,
+                                  gboolean usetextonly);
+
 static gdouble rsvg_text_length_text_as_string (RsvgDrawingCtx * ctx, const char *text);
 
 static int
@@ -248,6 +281,11 @@
                     out = _rsvg_node_text_length_tref (tref, ctx, length,
                                                        lastwasspace,
                                                        usetextonly);
+                } else if (type == RSVG_NODE_TYPE_TEXTPATH) {
+                    RsvgNodeTextPath *textpath = (RsvgNodeTextPath *) node;
+                    out = _rsvg_node_text_length_textpath (textpath, ctx, length,
+                                                           lastwasspace,
+                                                           usetextonly);
                 }
             }
         }
@@ -294,7 +332,7 @@
     y += dy;
 
     lastwasspace = TRUE;
-    _rsvg_node_text_type_children (self, ctx, &x, &y, &lastwasspace, FALSE);
+    _rsvg_node_text_type_children (self, ctx, &x, &y, &lastwasspace, FALSE, NULL);
 }
 
 RsvgNode *
@@ -312,7 +350,8 @@
 static void
 _rsvg_node_text_type_tspan (RsvgNodeText * self, RsvgDrawingCtx * ctx,
                             gdouble * x, gdouble * y, gboolean * lastwasspace,
-                            gboolean usetextonly)
+                            gboolean usetextonly,
+                            const cairo_path_t * path)
 {
     double dx, dy, length = 0;
     rsvg_state_reinherit_top (ctx, self->super.state, 0);
@@ -352,7 +391,7 @@
     }
     *y += dy;
     _rsvg_node_text_type_children (&self->super, ctx, x, y, lastwasspace,
-                                   usetextonly);
+                                   usetextonly, path);
 }
 
 static int
@@ -413,11 +452,12 @@
 static void
 _rsvg_node_text_type_tref (RsvgNodeTref * self, RsvgDrawingCtx * ctx,
                            gdouble * x, gdouble * y, gboolean * lastwasspace,
-                           gboolean usetextonly)
+                           gboolean usetextonly,
+                           const cairo_path_t * path)
 {
     if (self->link)
         _rsvg_node_text_type_children (self->link, ctx, x, y, lastwasspace,
-                                                              TRUE);
+                                       TRUE, path);
 }
 
 static int
@@ -454,6 +494,110 @@
     return &text->super;
 }
 
+static void
+_rsvg_node_text_type_textpath (RsvgNodeTextPath * self, RsvgDrawingCtx * ctx,
+                               gdouble * x, gdouble * y, gboolean * lastwasspace,
+                               gboolean usetextonly,
+                               const cairo_path_t * path)
+{
+    RsvgNodePath * newpath;
+
+    if(self->link == NULL)
+        return;
+
+    if(RSVG_NODE_TYPE(self->link) != RSVG_NODE_TYPE_PATH)
+        return;
+
+    rsvg_state_reinherit_top (ctx, self->super.state, 0);
+
+    /* Continue with the new path at the given offset */
+
+    newpath = (RsvgNodePath *) self->link;
+
+    if(self->startOffset.factor == 'p') {
+        *x += self->startOffset.length * path_length(newpath->path);
+    } else {
+        *x += self->startOffset.length;
+    }
+    
+    _rsvg_node_text_type_children (&self->super, ctx, x, y, lastwasspace,
+                                   usetextonly, newpath->path);
+}
+
+static int
+_rsvg_node_text_length_textpath (RsvgNodeTextPath * self,
+                                 RsvgDrawingCtx * ctx, gdouble * length,
+                                 gboolean * lastwasspace, gboolean usetextonly)
+{
+    if (self->link)
+        return _rsvg_node_text_length_children (&self->super, ctx, length,
+                                                lastwasspace, usetextonly);
+    return FALSE;
+}
+
+static void
+_rsvg_node_textpath_set_atts (RsvgNode * self, RsvgHandle * ctx, RsvgPropertyBag * atts)
+{
+    const char *klazz = NULL, *id = NULL, *value;
+    RsvgNodeTextPath *textpath = (RsvgNodeTextPath *) self;
+
+    textpath->dx = textpath->dy = _rsvg_css_parse_length ("0");
+
+    if (rsvg_property_bag_size (atts)) {
+        if ((value = rsvg_property_bag_lookup (atts, "startOffset")))
+            textpath->startOffset = _rsvg_css_parse_length (value);
+        if ((value = rsvg_property_bag_lookup (atts, "xlink:href")))
+            rsvg_defs_add_resolver (ctx->priv->defs, &textpath->link, value);
+        if ((value = rsvg_property_bag_lookup (atts, "class")))
+            klazz = value;
+        if ((value = rsvg_property_bag_lookup (atts, "id"))) {
+            id = value;
+            rsvg_defs_register_name (ctx->priv->defs, value, self);
+        }
+        if ((value = rsvg_property_bag_lookup (atts, "method"))) {
+            if(!strcmp(value, "align")) {
+                textpath->stretch = FALSE;
+            } else if(!strcmp(value, "stretch")) {
+                textpath->stretch = TRUE;
+            }
+            /* Ignore bad values */
+        }
+
+        /* Standardese: "A value of auto indicates that the user
+         * agent should use text-on-a-path layout algorithms to adjust
+         * the spacing between glyphs in order to achieve visually
+         * appealing results." We ignore the attribute.
+         */
+
+        if ((value = rsvg_property_bag_lookup (atts, "spacing"))) {
+            if(!strcmp(value, "auto")) {
+                textpath->autospacing = TRUE;
+            } else if(!strcmp(value, "exact")) {
+                textpath->autospacing = FALSE;
+            }
+            /* Ignore bad values */
+        }
+
+        rsvg_parse_style_attrs (ctx, self->state, "textPath", klazz, id, atts);
+    }
+}
+
+RsvgNode *
+rsvg_new_textpath (void)
+{
+    RsvgNodeTextPath *textpath;
+    textpath = g_new (RsvgNodeTextPath, 1);
+    _rsvg_node_init (&textpath->super, RSVG_NODE_TYPE_TEXTPATH);
+    textpath->super.set_atts = _rsvg_node_textpath_set_atts;
+    textpath->link = NULL;
+    textpath->stretch = FALSE;
+    textpath->autospacing = FALSE;
+    textpath->startOffset = _rsvg_css_parse_length ("0");
+    return &textpath->super;
+}
+
+
+
 typedef struct _RsvgTextLayout RsvgTextLayout;
 
 struct _RsvgTextLayout {
@@ -561,7 +705,7 @@
 }
 
 void
-rsvg_text_render_text (RsvgDrawingCtx * ctx, const char *text, gdouble * x, gdouble * y)
+rsvg_text_render_text (RsvgDrawingCtx * ctx, const char *text, gdouble * x, gdouble * y, const cairo_path_t * path)
 {
     PangoContext *context;
     PangoLayout *layout;
@@ -587,7 +731,7 @@
         offsetY = pango_layout_iter_get_baseline (iter) / (double)PANGO_SCALE;
     }
     pango_layout_iter_free (iter);
-    ctx->render->render_pango_layout (ctx, layout, *x - offsetX, *y - offsetY);
+    ctx->render->render_pango_layout (ctx, layout, *x - offsetX, *y - offsetY, path);
     if (PANGO_GRAVITY_IS_VERTICAL (state->text_gravity))
         *y += w / (double)PANGO_SCALE;
     else
diff --new-file --recursive --unified librsvg-2.40.6-orig/rsvg-text.h librsvg-2.40.6/rsvg-text.h
--- librsvg-2.40.6-orig/rsvg-text.h	2014-12-03 10:23:51.000000000 +0000
+++ librsvg-2.40.6/rsvg-text.h	2014-03-03 08:31:18.000000000 +0000
@@ -39,6 +39,8 @@
 G_GNUC_INTERNAL
 RsvgNode    *rsvg_new_tref	    (void);
 G_GNUC_INTERNAL
+RsvgNode    *rsvg_new_textpath  (void);
+G_GNUC_INTERNAL
 char	    *rsvg_make_valid_utf8   (const char *str, int len);
 
 G_END_DECLS
diff --new-file --recursive --unified librsvg-2.40.6-orig/rsvg-twisted.c librsvg-2.40.6/rsvg-twisted.c
--- librsvg-2.40.6-orig/rsvg-twisted.c	1970-01-01 00:00:00.000000000 +0000
+++ librsvg-2.40.6/rsvg-twisted.c	2014-03-03 08:30:46.000000000 +0000
@@ -0,0 +1,376 @@
+/*
+ * This code is copied from cairotwisted.c in Pango examples:
+ *
+ * https://github.com/phuang/pango/blob/master/examples/cairotwisted.c
+ *
+ * Written by Behdad Esfahbod, 2006..2007
+ * Copied to librsvg by Mika Heiskanen, 2014
+ *
+ * Permission to use, copy, modify, distribute, and sell this example
+ * for any purpose is hereby granted without fee.
+ * It is provided "as is" without express or implied warranty.
+ */
+
+#include <math.h>
+#include <stdlib.h>
+#include <pango/pangocairo.h>
+
+
+/* Returns Euclidean distance between two points */
+static double
+chord_length (double x1, double y1, double x2, double y2)
+{
+  double dx, dy;
+  dx = x2-x1;
+  dy = y2-y1;
+  return sqrt (dx * dx + dy * dy);
+}
+
+/* Returns length of a Bezier curve.
+ * Seems like computing that analytically is not easy.  The
+ * code just flattens the curve using cairo and adds the length
+ * of segments.
+ */
+
+static double
+cubic_length(double x1, double y1,
+	     double x2, double y2,
+	     double x3, double y3,
+	     double x4, double y4)
+{
+  double eps, chord, arc, l1, l2;
+  double xb1, xb2, xb3, xc1, xc2, xd1;
+  double yb1, yb2, yb3, yc1, yc2, yd1;
+
+  chord = chord_length(x1,y1,x4,y4);
+
+  if(chord == 0)
+    return 0;
+
+  arc = (chord_length(x1,y1,x2,y2) +
+	 chord_length(x2,y2,x3,y3) +
+	 chord_length(x3,y3,x4,y4));
+
+  /* If relative difference is small, the mean of the values
+   * is a good estimate.
+   */
+
+  eps = 0.01;
+
+  if( (arc-chord)/arc < eps)
+    return 0.5*(arc+chord);
+
+  xb1 = (x1+x2)/2;   yb1 = (y1+y2)/2;
+  xb2 = (x2+x3)/2;   yb2 = (y2+y3)/2;
+  xb3 = (x3+x4)/2;   yb3 = (y3+y4)/2;
+  xc1 = (xb1+xb2)/2; yc1 = (yb1+yb2)/2;
+  xc2 = (xb2+xb3)/2; yc2 = (yb2+yb3)/2;
+  xd1 = (xc1+xc2)/2; yd1 = (yc1+yc2)/2;
+
+  l1 = cubic_length(x1,y1, xb1,yb1, xc1,yc1, xd1,yd1);
+  l2 = cubic_length(xd1,yd1, xc2,yc2, xb3,yb3, x4,y4);
+
+  return l1+l2;
+}
+
+typedef double parametrization_t;
+
+/* Compute parametrization info.  That is, for each part of the 
+ * cairo path, tags it with its length.
+ *
+ * Free returned value with g_free().
+ */
+static parametrization_t *
+parametrize_path (cairo_path_t *path)
+{
+  int i;
+  cairo_path_data_t *data, last_move_to, current_point;
+  parametrization_t *parametrization;
+
+  parametrization = g_malloc (path->num_data * sizeof (parametrization[0]));
+
+  for (i=0; i < path->num_data; i += path->data[i].header.length) {
+      data = &path->data[i];
+      parametrization[i] = 0.0;
+      switch (data->header.type) {
+      case CAIRO_PATH_MOVE_TO:
+          last_move_to = data[1];
+          current_point = data[1];
+          break;
+      case CAIRO_PATH_CLOSE_PATH:
+          /* Make it look like it's a line_to to last_move_to */
+          data = (&last_move_to) - 1;
+          /* fall through */
+      case CAIRO_PATH_LINE_TO:
+	parametrization[i] = chord_length (current_point.point.x,
+					   current_point.point.y,
+					   data[1].point.x,
+					   data[1].point.y);
+	current_point = data[1];
+	break;
+      case CAIRO_PATH_CURVE_TO:
+          parametrization[i] = cubic_length (current_point.point.x, current_point.point.y,
+                                             data[1].point.x, data[1].point.y,
+                                             data[2].point.x, data[2].point.y,
+                                             data[3].point.x, data[3].point.y);
+          
+          current_point = data[3];
+          break;
+      default:
+          g_assert_not_reached ();
+      }
+  }
+  
+  return parametrization;
+}
+
+/* Compute path length */
+
+double path_length (const cairo_path_t * path)
+{
+  double length;
+  int i;
+  cairo_path_data_t *data, last_move_to, current_point;
+
+  if(!path)
+    return 0;
+
+  length = 0;
+  for (i=0; i < path->num_data; i += path->data[i].header.length) {
+      data = &path->data[i];
+      switch (data->header.type) {
+      case CAIRO_PATH_MOVE_TO:
+          last_move_to = data[1];
+          current_point = data[1];
+          break;
+      case CAIRO_PATH_CLOSE_PATH:
+          /* Make it look like it's a line_to to last_move_to */
+          data = (&last_move_to) - 1;
+          /* fall through */
+      case CAIRO_PATH_LINE_TO:
+	length += chord_length (current_point.point.x,
+				current_point.point.y,
+				data[1].point.x,
+				data[1].point.y);
+          current_point = data[1];
+          break;
+      case CAIRO_PATH_CURVE_TO:
+          /* naive curve-length, treating bezier as three line segments:
+             parametrization[i] = two_points_distance (&current_point, &data[1])
+             + two_points_distance (&data[1], &data[2])
+             + two_points_distance (&data[2], &data[3]);
+          */
+	  length += cubic_length (current_point.point.x, current_point.point.y,
+				  data[1].point.x, data[1].point.y,
+				  data[2].point.x, data[2].point.y,
+				  data[3].point.x, data[3].point.y);
+          current_point = data[3];
+          break;
+      default:
+          g_assert_not_reached ();
+      }
+  }
+  
+  return length;
+}
+
+
+typedef void (*transform_point_func_t) (void *closure, double *x, double *y);
+
+/* Project a path using a function.  Each point of the path (including
+ * Bezier control points) is passed to the function for transformation.
+ */
+static void
+transform_path (cairo_path_t *path, transform_point_func_t f, void *closure)
+{
+  int i;
+  cairo_path_data_t *data;
+
+  for (i=0; i < path->num_data; i += path->data[i].header.length) {
+    data = &path->data[i];
+    switch (data->header.type) {
+    case CAIRO_PATH_CURVE_TO:
+      f (closure, &data[3].point.x, &data[3].point.y);
+      f (closure, &data[2].point.x, &data[2].point.y);
+    case CAIRO_PATH_MOVE_TO:
+    case CAIRO_PATH_LINE_TO:
+      f (closure, &data[1].point.x, &data[1].point.y);
+      break;
+    case CAIRO_PATH_CLOSE_PATH:
+      break;
+    default:
+	g_assert_not_reached ();
+    }
+  }
+}
+
+
+/* Simple struct to hold a path and its parametrization */
+typedef struct {
+  cairo_path_t *path;
+  parametrization_t *parametrization;
+} parametrized_path_t;
+
+
+/* Project a point X,Y onto a parameterized path.  The final point is
+ * where you get if you walk on the path forward from the beginning for X
+ * units, then stop there and walk another Y units perpendicular to the
+ * path at that point.  In more detail:
+ *
+ * There's three pieces of math involved:
+ *
+ *   - The parametric form of the Line equation
+ *     http://en.wikipedia.org/wiki/Line
+ *
+ *   - The parametric form of the Cubic Bézier curve equation
+ *     http://en.wikipedia.org/wiki/B%C3%A9zier_curve
+ *
+ *   - The Gradient (aka multi-dimensional derivative) of the above
+ *     http://en.wikipedia.org/wiki/Gradient
+ *
+ * The parametric forms are used to answer the question of "where will I be
+ * if I walk a distance of X on this path".  The Gradient is used to answer
+ * the question of "where will I be if then I stop, rotate left for 90
+ * degrees and walk straight for a distance of Y".
+ */
+static void
+point_on_path (parametrized_path_t *param,
+	       double *x, double *y)
+{
+  int i;
+  double ratio, the_y = *y, the_x = *x, dx, dy;
+  cairo_path_data_t *data, last_move_to, current_point;
+  cairo_path_t *path = param->path;
+  parametrization_t *parametrization = param->parametrization;
+
+  for (i=0; i + path->data[i].header.length < path->num_data &&
+	    (the_x > parametrization[i] ||
+	     path->data[i].header.type == CAIRO_PATH_MOVE_TO);
+       i += path->data[i].header.length) {
+    the_x -= parametrization[i];
+    data = &path->data[i];
+    switch (data->header.type) {
+    case CAIRO_PATH_MOVE_TO:
+	current_point = data[1];
+        last_move_to = data[1];
+	break;
+    case CAIRO_PATH_LINE_TO:
+	current_point = data[1];
+	break;
+    case CAIRO_PATH_CURVE_TO:
+	current_point = data[3];
+	break;
+    case CAIRO_PATH_CLOSE_PATH:
+	break;
+    default:
+	g_assert_not_reached ();
+    }
+  }
+  data = &path->data[i];
+
+  switch (data->header.type) {
+
+  case CAIRO_PATH_MOVE_TO:
+      break;
+  case CAIRO_PATH_CLOSE_PATH:
+      /* Make it look like it's a line_to to last_move_to */
+      data = (&last_move_to) - 1;
+      /* fall through */
+  case CAIRO_PATH_LINE_TO:
+      {
+	ratio = the_x / parametrization[i];
+	/* Line polynomial */
+	*x = current_point.point.x * (1 - ratio) + data[1].point.x * ratio;
+	*y = current_point.point.y * (1 - ratio) + data[1].point.y * ratio;
+
+	/* Line gradient */
+	dx = -(current_point.point.x - data[1].point.x);
+	dy = -(current_point.point.y - data[1].point.y);
+
+	/*optimization for: ratio = the_y / sqrt (dx * dx + dy * dy);*/
+	ratio = the_y / parametrization[i];
+	*x += -dy * ratio;
+	*y +=  dx * ratio;
+      }
+      break;
+  case CAIRO_PATH_CURVE_TO:
+      {
+	/* FIXME the formulas here are not exactly what we want, because the
+	 * Bezier parametrization is not uniform.  But I don't know how to do
+	 * better.  The caller can do slightly better though, by flattening the
+	 * Bezier and avoiding this branch completely.  That has its own cost
+	 * though, as large y values magnify the flattening error drastically.
+	 */
+
+        double ratio_1_0, ratio_0_1;
+	double ratio_2_0, ratio_0_2;
+	double ratio_3_0, ratio_2_1, ratio_1_2, ratio_0_3;
+	double _1__4ratio_1_0_3ratio_2_0, _2ratio_1_0_3ratio_2_0;
+
+	ratio = the_x / parametrization[i];
+
+	ratio_1_0 = ratio;
+	ratio_0_1 = 1 - ratio;
+
+	ratio_2_0 = ratio_1_0 * ratio_1_0; /*      ratio  *      ratio  */
+	ratio_0_2 = ratio_0_1 * ratio_0_1; /* (1 - ratio) * (1 - ratio) */
+
+	ratio_3_0 = ratio_2_0 * ratio_1_0; /*      ratio  *      ratio  *      ratio  */
+	ratio_2_1 = ratio_2_0 * ratio_0_1; /*      ratio  *      ratio  * (1 - ratio) */
+	ratio_1_2 = ratio_1_0 * ratio_0_2; /*      ratio  * (1 - ratio) * (1 - ratio) */
+	ratio_0_3 = ratio_0_1 * ratio_0_2; /* (1 - ratio) * (1 - ratio) * (1 - ratio) */
+
+	_1__4ratio_1_0_3ratio_2_0 = 1 - 4 * ratio_1_0 + 3 * ratio_2_0;
+	_2ratio_1_0_3ratio_2_0    =     2 * ratio_1_0 - 3 * ratio_2_0;
+
+	/* Bezier polynomial */
+	*x = current_point.point.x * ratio_0_3
+	   + 3 *   data[1].point.x * ratio_1_2
+	   + 3 *   data[2].point.x * ratio_2_1
+	   +       data[3].point.x * ratio_3_0;
+	*y = current_point.point.y * ratio_0_3
+	   + 3 *   data[1].point.y * ratio_1_2
+	   + 3 *   data[2].point.y * ratio_2_1
+	   +       data[3].point.y * ratio_3_0;
+
+	/* Bezier gradient */
+	dx =-3 * current_point.point.x * ratio_0_2
+	   + 3 *       data[1].point.x * _1__4ratio_1_0_3ratio_2_0
+	   + 3 *       data[2].point.x * _2ratio_1_0_3ratio_2_0
+	   + 3 *       data[3].point.x * ratio_2_0;
+	dy =-3 * current_point.point.y * ratio_0_2
+	   + 3 *       data[1].point.y * _1__4ratio_1_0_3ratio_2_0
+	   + 3 *       data[2].point.y * _2ratio_1_0_3ratio_2_0
+	   + 3 *       data[3].point.y * ratio_2_0;
+
+	ratio = the_y / sqrt (dx * dx + dy * dy);
+	*x += -dy * ratio;
+	*y +=  dx * ratio;
+      }
+      break;
+  default:
+      g_assert_not_reached ();
+  }
+}
+
+/* Projects the current path of cr onto the provided path. */
+void
+map_path_onto (cairo_t *cr, cairo_path_t *path)
+{
+  cairo_path_t *current_path;
+  parametrized_path_t param;
+
+  param.path = path;
+  param.parametrization = parametrize_path (path);
+
+  current_path = cairo_copy_path (cr);
+  cairo_new_path (cr);
+
+  transform_path (current_path,
+		  (transform_point_func_t) point_on_path, &param);
+
+  cairo_append_path (cr, current_path);
+
+  cairo_path_destroy (current_path);
+  g_free (param.parametrization);
+}
diff --new-file --recursive --unified librsvg-2.40.6-orig/rsvg-twisted.h librsvg-2.40.6/rsvg-twisted.h
--- librsvg-2.40.6-orig/rsvg-twisted.h	1970-01-01 00:00:00.000000000 +0000
+++ librsvg-2.40.6/rsvg-twisted.h	2014-03-03 08:30:46.000000000 +0000
@@ -0,0 +1,22 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim: set sw=4 sts=4 ts=4 expandtab: */
+/*
+  rsvg-twisted.h
+
+*/
+
+#ifndef RSVG_TWISTED_H
+#define RSVG_TWISTED_H
+
+#include "rsvg-private.h"
+
+G_BEGIN_DECLS
+
+G_GNUC_INTERNAL
+void map_path_onto (cairo_t *cr, cairo_path_t *path);
+double path_length (const cairo_path_t * path);
+
+G_END_DECLS
+
+#endif /* RSVG_TWISTED_H */
+
